# 종이붙이기.ipynb

'''
어린이 알고리즘 교실의 선생님은 경우의 수 놀이를 위해, 그림처럼 가로x세로 길이가 10x20, 20x20인 직사각형 종이를 잔뜩 준비했다.

10의 배수인 N이 주어졌을 때, 종이를 붙이는 모든 경우를 찾으려면 테이프로 만든 표시한 영역을 몇 개나 만들어야 되는지 계산하는 프로그램을 만드시오. 직사각형 종이가 모자라는 경우는 없다.

[입력]

첫 줄에 테스트 케이스 개수 T가 주어진다.  1≤T≤50
다음 줄부터 테스트 케이스 별로 N이 주어진다. 10≤N≤300, N은 10의 배수

[출력]

각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.
'''

# 문제를 잘 살펴보면 경우의 수 문제이다
# 긴 종이와 정사각형 종이로 생각해 볼 수 있는데
# 이는 그대로인 20 * 20 짜리 종이와 가로로 누운 10 * 20 종이를
# 붙여 놓은 것으로 생각할 수 있다. 
# 따라서 정사각형 종이의 개수를 기준으로 경우의 수를 세어보면 된다
# n = N / 10 이라 할 때 정사각형과 긴 종이를 나열하는 경우는
# combination[n-r, r] 이고 여기서 r개의 정사각형 종이가
# 20 * 20 일 수도 있고 두 개를 이어붙인 것 일 수도 있으므로
# 2**r 을 곱해준다
# 이를 r이 0일 때부터 가장 많은 k개 (=int(n/2)) 까지의 경우로 더해준다

# factorial
def fac(n) :
    if 0 <= n <= 1 :
        return 1
    else :
        return n * fac(n-1)

# comb[n, r]
def combination(n, r) :
    return int(fac(n) / (fac(n-r) * fac(r)))

T = int(input())
for testCase in range(1, T+1) :
    N = int(input())

    n = int(N/10)
    k = int(n/2)
        
    # r: 정사각형의 갯수
    answer = 0
    for r in range(k+1) :
        answer += combination(n-r, r) * (2**r)

    print('#{0} {1}'.format(testCase, answer))